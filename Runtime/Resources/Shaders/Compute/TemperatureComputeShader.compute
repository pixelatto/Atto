#pragma kernel CSMain

// Texturas para las temperaturas actuales y próximas
RWTexture2D<float> Result;
Texture2D<float> CurrentTemperatures;

// Parámetros de entrada
int width;
int height;
float ambientTemperature;
float ambientTemperatureDelta;
float ambientConductivity;
float dampingFactor; // Nueva variable para amortiguación

// Estructura para las propiedades de la celda
struct TemperatureCell
{
    float temperature;
    float thermalConductivity;
    int material;
};

StructuredBuffer<TemperatureCell> cells;

// Vecinos
static const int2 offsets[4] = { int2(0, 1), int2(0, -1), int2(1, 0), int2(-1, 0) };

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    int x = id.x;
    int y = id.y;

    if (x >= width || y >= height)
        return;

    int index = y * width + x;
    TemperatureCell cell = cells[index];

    float sumTemperatures = 0.0;
    float sumConductivities = 0.0;

    for (int i = 0; i < 4; i++)
    {
        int2 neighborPos = int2(x, y) + offsets[i];
        if (neighborPos.x >= 0 && neighborPos.x < width && neighborPos.y >= 0 && neighborPos.y < height)
        {
            float neighborTemperature = CurrentTemperatures.Load(int3(neighborPos, 0));
            TemperatureCell neighborCell = cells[neighborPos.y * width + neighborPos.x];

            sumTemperatures += neighborTemperature * neighborCell.thermalConductivity;
            sumConductivities += neighborCell.thermalConductivity;
        }
    }

    // Añadir contribución de la temperatura ambiente para celdas vacías
    if (cell.material == 0) // Empty
    {
        float perlinNoise = frac(sin(dot(float2(x, y), float2(12.9898, 78.233))) * 43758.5453) * ambientTemperatureDelta;
        float adjustedAmbientTemperature = ambientTemperature + perlinNoise;
        sumTemperatures += adjustedAmbientTemperature * ambientConductivity;
        sumConductivities += ambientConductivity;
    }

    if (sumConductivities > 0)
    {
        float averageNeighborTemperature = sumTemperatures / sumConductivities;
        float temperatureChange = (averageNeighborTemperature - cell.temperature) * (cell.thermalConductivity / (cell.thermalConductivity + sumConductivities));
        temperatureChange *= dampingFactor; // Aplicar factor de amortiguación
        Result[int2(x, y)] = cell.temperature + temperatureChange;
    }
    else
    {
        Result[int2(x, y)] = cell.temperature;
    }
}
